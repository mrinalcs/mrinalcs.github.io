import t from "../../delegate-it@6.1.0/delegate.js?module";import { match as e } from "../../path-to-regexp@6.2.2/dist.es2015/index.js?module";const n = (t, e) => String(t).toLowerCase().replace(/[\s/_.]+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+|-+$/g, "") || e || "",o = ({ hash: t } = {}) => window.location.pathname + window.location.search + (t ? window.location.hash : ""),r = (t, e = {}) => {const n = { url: t = t || o({ hash: !0 }), random: Math.random(), source: "swup", ...e };window.history.pushState(n, "", t);},i = (t = null, e = {}) => {t = t || o({ hash: !0 });const n = { ...(window.history.state || {}), url: t, random: Math.random(), source: "swup", ...e };window.history.replaceState(n, "", t);},s = (e, n, o, r) => {const i = new AbortController();return r = { ...r, signal: i.signal }, t(e, n, o, r), { destroy: () => i.abort() };};class a extends URL {constructor(t, e = document.baseURI) {super(t.toString(), e), Object.setPrototypeOf(this, a.prototype);}get url() {return this.pathname + this.search;}static fromElement(t) {const e = t.getAttribute("href") || t.getAttribute("xlink:href") || "";return new a(e);}static fromUrl(t) {return new a(t);}}const c = (t, n) => {try {return e(t, n);} catch (e) {throw new Error(`[swup] Error parsing path "${String(t)}":\n${String(e)}`);}},l = function (t, e = {}) {try {var _e$timeout;const o = this;function n(n) {const { status: i, url: s } = u;return Promise.resolve(u.text()).then(function (n) {if (500 === i) throw o.hooks.call("fetch:error", r, { status: i, response: u, url: s }), new h(`Server error: ${s}`, { status: i, url: s });if (!n) throw new h(`Empty response: ${s}`, { status: i, url: s });const { url: c } = a.fromUrl(s),l = { url: c, html: n };return !r.cache.write || e.method && "GET" !== e.method || t !== c || o.cache.set(l.url, l), l;});}t = a.fromUrl(t).url;const { visit: r = o.visit } = e,i = { ...o.options.requestHeaders, ...e.headers },s = (_e$timeout = e.timeout) !== null && _e$timeout !== void 0 ? _e$timeout : o.options.timeout,c = new AbortController(),{ signal: l } = c;e = { ...e, headers: i, signal: l };let u,d = !1,m = null;s && s > 0 && (m = setTimeout(() => {d = !0, c.abort("timeout");}, s));const f = function (n, i) {try {var s = Promise.resolve(o.hooks.call("fetch:request", r, { url: t, options: e }, (t, { url: e, options: n }) => fetch(e, n))).then(function (t) {u = t, m && clearTimeout(m);});} catch (t) {return i(t);}return s && s.then ? s.then(void 0, i) : s;}(0, function (e) {if (d) throw o.hooks.call("fetch:timeout", r, { url: t }), new h(`Request timed out: ${t}`, { url: t, timedOut: d });if ("AbortError" === (e === null || e === void 0 ? void 0 : e.name) || l.aborted) throw new h(`Request aborted: ${t}`, { url: t, aborted: !0 });throw e;});return Promise.resolve(f && f.then ? f.then(n) : n());} catch (p) {return Promise.reject(p);}};class h extends Error {constructor(t, e) {super(t), this.url = void 0, this.status = void 0, this.aborted = void 0, this.timedOut = void 0, this.name = "FetchError", this.url = e.url, this.status = e.status, this.aborted = e.aborted || !1, this.timedOut = e.timedOut || !1;}}class u {constructor(t) {this.swup = void 0, this.pages = new Map(), this.swup = t;}get size() {return this.pages.size;}get all() {const t = new Map();return this.pages.forEach((e, n) => {t.set(n, { ...e });}), t;}has(t) {return this.pages.has(this.resolve(t));}get(t) {const e = this.pages.get(this.resolve(t));return e ? { ...e } : e;}set(t, e) {t = this.resolve(t), e = { ...e, url: t }, this.pages.set(t, e), this.swup.hooks.callSync("cache:set", void 0, { page: e });}update(t, e) {t = this.resolve(t);const n = { ...this.get(t), ...e, url: t };this.pages.set(t, n);}delete(t) {this.pages.delete(this.resolve(t));}clear() {this.pages.clear(), this.swup.hooks.callSync("cache:clear", void 0, void 0);}prune(t) {this.pages.forEach((e, n) => {t(n, e) && this.delete(n);});}resolve(t) {const { url: e } = a.fromUrl(t);return this.swup.resolveUrl(e);}}const d = (t, e = document) => e.querySelector(t),m = (t, e = document) => Array.from(e.querySelectorAll(t)),f = () => new Promise(t => {requestAnimationFrame(() => {requestAnimationFrame(() => {t();});});});function p(t) {return !!t && ("object" == typeof t || "function" == typeof t) && "function" == typeof t.then;}function v(t, e = []) {return new Promise((n, o) => {const r = t(...e);p(r) ? r.then(n, o) : n(r);});}function g(t) {var _t;t = t || document.body, (_t = t) === null || _t === void 0 ? void 0 : _t.getBoundingClientRect();}class w {constructor(t) {this.swup = void 0, this.swupClasses = ["to-", "is-changing", "is-rendering", "is-popstate", "is-animating", "is-leaving"], this.swup = t;}get selectors() {const { scope: t } = this.swup.visit.animation;return "containers" === t ? this.swup.visit.containers : "html" === t ? ["html"] : Array.isArray(t) ? t : [];}get selector() {return this.selectors.join(",");}get targets() {return this.selector.trim() ? m(this.selector) : [];}add() {this.targets.forEach(t => t.classList.add(...[].slice.call(arguments)));}remove() {this.targets.forEach(t => t.classList.remove(...[].slice.call(arguments)));}clear() {this.targets.forEach(t => {const e = t.className.split(" ").filter(t => this.isSwupClass(t));t.classList.remove(...e);});}isSwupClass(t) {return this.swupClasses.some(e => t.startsWith(e));}}class y {constructor(t, e) {this.id = void 0, this.state = void 0, this.from = void 0, this.to = void 0, this.containers = void 0, this.animation = void 0, this.trigger = void 0, this.cache = void 0, this.history = void 0, this.scroll = void 0;const { to: n, from: o = t.currentPageUrl, hash: r, el: i, event: s } = e;this.id = Math.random(), this.state = 1, this.from = { url: o }, this.to = { url: n, hash: r }, this.containers = t.options.containers, this.animation = { animate: !0, wait: !1, name: void 0, native: t.options.native, scope: t.options.animationScope, selector: t.options.animationSelector }, this.trigger = { el: i, event: s }, this.cache = { read: t.options.cache, write: t.options.cache }, this.history = { action: "push", popstate: !1, direction: void 0 }, this.scroll = { reset: !0, target: void 0 };}advance(t) {this.state < t && (this.state = t);}abort() {this.state = 8;}get done() {return this.state >= 7;}}function P(t) {return new y(this, t);}const k = "undefined" != typeof Symbol ? Symbol.iterator || (Symbol.iterator = Symbol("Symbol.iterator")) : "@@iterator";function b(t, e, n) {if (!t.s) {if (n instanceof S) {if (!n.s) return void (n.o = b.bind(null, t, e));1 & e && (e = n.s), n = n.v;}if (n && n.then) return void n.then(b.bind(null, t, e), b.bind(null, t, 2));t.s = e, t.v = n;const o = t.o;o && o(t);}}const S = /*#__PURE__*/function () {function t() {}return t.prototype.then = function (e, n) {const o = new t(),r = this.s;if (r) {const t = 1 & r ? e : n;if (t) {try {b(o, 1, t(this.v));} catch (t) {b(o, 2, t);}return o;}return this;}return this.o = function (t) {try {const r = t.v;1 & t.s ? b(o, 1, e ? e(r) : r) : n ? b(o, 1, n(r)) : b(o, 2, r);} catch (t) {b(o, 2, t);}}, o;}, t;}();function E(t) {return t instanceof S && 1 & t.s;}class U {constructor(t) {this.swup = void 0, this.registry = new Map(), this.hooks = ["animation:out:start", "animation:out:await", "animation:out:end", "animation:in:start", "animation:in:await", "animation:in:end", "animation:skip", "cache:clear", "cache:set", "content:replace", "content:scroll", "enable", "disable", "fetch:request", "fetch:error", "fetch:timeout", "history:popstate", "link:click", "link:self", "link:anchor", "link:newtab", "page:load", "page:view", "scroll:top", "scroll:anchor", "visit:start", "visit:transition", "visit:abort", "visit:end"], this.swup = t, this.init();}init() {this.hooks.forEach(t => this.create(t));}create(t) {this.registry.has(t) || this.registry.set(t, new Map());}exists(t) {return this.registry.has(t);}get(t) {const e = this.registry.get(t);if (e) return e;console.error(`Unknown hook '${t}'`);}clear() {this.registry.forEach(t => t.clear());}on(t, e, n = {}) {const o = this.get(t);if (!o) return console.warn(`Hook '${t}' not found.`), () => {};const r = { ...n, id: o.size + 1, hook: t, handler: e };return o.set(e, r), () => this.off(t, e);}before(t, e, n = {}) {return this.on(t, e, { ...n, before: !0 });}replace(t, e, n = {}) {return this.on(t, e, { ...n, replace: !0 });}once(t, e, n = {}) {return this.on(t, e, { ...n, once: !0 });}off(t, e) {const n = this.get(t);n && e ? n.delete(e) || console.warn(`Handler for hook '${t}' not found.`) : n && n.clear();}call(t, e, n, o) {try {const r = this,[i, s, a] = r.parseCallArgs(t, e, n, o),{ before: c, handler: l, after: h } = r.getHandlers(t, a);return Promise.resolve(r.run(c, i, s)).then(function () {return Promise.resolve(r.run(l, i, s, !0)).then(function ([e]) {return Promise.resolve(r.run(h, i, s)).then(function () {return r.dispatchDomEvent(t, i, s), e;});});});} catch (t) {return Promise.reject(t);}}callSync(t, e, n, o) {const [r, i, s] = this.parseCallArgs(t, e, n, o),{ before: a, handler: c, after: l } = this.getHandlers(t, s);this.runSync(a, r, i);const [h] = this.runSync(c, r, i, !0);return this.runSync(l, r, i), this.dispatchDomEvent(t, r, i), h;}parseCallArgs(t, e, n, o) {return e instanceof y || "object" != typeof e && "function" != typeof n ? [e, n, o] : [void 0, e, n];}run(t, e, n, o = !1) {try {let r;const i = this;void 0 === e && (e = i.swup.visit);const s = [],a = function (t, e, n) {if ("function" == typeof t[k]) {var o,r,i,s = t[k]();if (function t(a) {try {for (; !((o = s.next()).done || n && n());) if ((a = e(o.value)) && a.then) {if (!E(a)) return void a.then(t, i || (i = b.bind(null, r = new S(), 2)));a = a.v;}r ? b(r, 1, a) : r = a;} catch (t) {b(r || (r = new S()), 2, t);}}(), s.return) {var a = function (t) {try {o.done || s.return();} catch (t) {}return t;};if (r && r.then) return r.then(a, function (t) {throw a(t);});a();}return r;}if (!("length" in t)) throw new TypeError("Object is not iterable");for (var c = [], l = 0; l < t.length; l++) c.push(t[l]);return function (t, e, n) {var o,r,i = -1;return function s(a) {try {for (; ++i < t.length && (!n || !n());) if ((a = e(i)) && a.then) {if (!E(a)) return void a.then(s, r || (r = b.bind(null, o = new S(), 2)));a = a.v;}o ? b(o, 1, a) : o = a;} catch (t) {b(o || (o = new S()), 2, t);}}(), o;}(c, function (t) {return e(c[t]);}, n);}(t, function ({ hook: t, handler: r, defaultHandler: a, once: c }) {var _e;if (!((_e = e) !== null && _e !== void 0 && _e.done)) return c && i.off(t, r), function (t, o) {try {var i = Promise.resolve(v(r, [e, n, a])).then(function (t) {s.push(t);});} catch (t) {return o(t);}return i && i.then ? i.then(void 0, o) : i;}(0, function (e) {if (o) throw e;console.error(`Error in hook '${t}':`, e);});}, function () {return r;});return Promise.resolve(a && a.then ? a.then(function (t) {return r ? t : s;}) : r ? a : s);} catch (t) {return Promise.reject(t);}}runSync(t, e = this.swup.visit, n, o = !1) {const r = [];for (const { hook: i, handler: s, defaultHandler: a, once: c } of t) if (!(e !== null && e !== void 0 && e.done)) {c && this.off(i, s);try {const t = s(e, n, a);r.push(t), p(t) && console.warn(`Swup will not await Promises in handler for synchronous hook '${i}'.`);} catch (t) {if (o) throw t;console.error(`Error in hook '${i}':`, t);}}return r;}getHandlers(t, e) {const n = this.get(t);if (!n) return { found: !1, before: [], handler: [], after: [], replaced: !1 };const o = Array.from(n.values()),r = this.sortRegistrations,i = o.filter(({ before: t, replace: e }) => t && !e).sort(r),s = o.filter(({ replace: t }) => t).filter(t => !0).sort(r),a = o.filter(({ before: t, replace: e }) => !t && !e).sort(r),c = s.length > 0;let l = [];if (e && (l = [{ id: 0, hook: t, handler: e }], c)) {const n = s.length - 1,o = t => {const n = s[t - 1];return n ? (e, r) => n.handler(e, r, o(t - 1)) : e;};l = [{ id: 0, hook: t, handler: s[n].handler, defaultHandler: o(n) }];}return { found: !0, before: i, handler: l, after: a, replaced: c };}sortRegistrations(t, e) {var _t$priority, _e$priority;return ((_t$priority = t.priority) !== null && _t$priority !== void 0 ? _t$priority : 0) - ((_e$priority = e.priority) !== null && _e$priority !== void 0 ? _e$priority : 0) || t.id - e.id || 0;}dispatchDomEvent(t, e, n) {if (e !== null && e !== void 0 && e.done) return;const o = { hook: t, args: n, visit: e || this.swup.visit };document.dispatchEvent(new CustomEvent("swup:any", { detail: o, bubbles: !0 })), document.dispatchEvent(new CustomEvent(`swup:${t}`, { detail: o, bubbles: !0 }));}}const C = t => {if (t && "#" === t.charAt(0) && (t = t.substring(1)), !t) return null;const e = decodeURIComponent(t);let n = document.getElementById(t) || document.getElementById(e) || d(`a[name='${CSS.escape(t)}']`) || d(`a[name='${CSS.escape(e)}']`);return n || "top" !== t || (n = document.body), n;},$ = function ({ elements: t, selector: e }) {try {if (!1 === e && !t) return Promise.resolve();let n = [];if (t) n = Array.from(t);else if (e && (n = m(e, document.body), !n.length)) return console.warn(`[swup] No elements found matching animationSelector \`${e}\``), Promise.resolve();const o = n.map(t => function (t) {const { type: e, timeout: n, propCount: o } = function (t) {const e = window.getComputedStyle(t),n = H(e, `${x}Delay`),o = H(e, `${x}Duration`),r = j(n, o),i = H(e, `${A}Delay`),s = H(e, `${A}Duration`),a = j(i, s),c = Math.max(r, a),l = c > 0 ? r > a ? x : A : null;return { type: l, timeout: c, propCount: l ? l === x ? o.length : s.length : 0 };}(t);return !(!e || !n) && new Promise(r => {const i = `${e}end`,s = performance.now();let a = 0;const c = () => {t.removeEventListener(i, l), r();},l = e => {if (e.target === t) {if (!function (t) {return [`${x}end`, `${A}end`].includes(t.type);}(e)) throw new Error("Not a transition or animation event.");(performance.now() - s) / 1e3 < e.elapsedTime || ++a >= o && c();}};setTimeout(() => {a < o && c();}, n + 1), t.addEventListener(i, l);});}(t));return o.filter(Boolean).length > 0 ? Promise.resolve(Promise.all(o)).then(function () {}) : (e && console.warn(`[swup] No CSS animation duration defined on elements matching \`${e}\``), Promise.resolve());} catch (t) {return Promise.reject(t);}},x = "transition",A = "animation";function H(t, e) {return (t[e] || "").split(", ");}function j(t, e) {for (; t.length < e.length;) t = t.concat(t);return Math.max(...e.map((e, n) => V(e) + V(t[n])));}function V(t) {return 1e3 * parseFloat(t);}const I = function (t, e = {}) {try {let a;const c = this;function s(s) {var _e$cache$read, _e$cache$write;if (a) return s;c.navigating = !0, c.visit = t;const { el: l } = t.trigger;e.referrer = e.referrer || c.currentPageUrl, !1 === e.animate && (t.animation.animate = !1), t.animation.animate || c.classes.clear();const h = e.history || (l === null || l === void 0 ? void 0 : l.getAttribute("data-swup-history")) || void 0;h && ["push", "replace"].includes(h) && (t.history.action = h);const u = e.animation || (l === null || l === void 0 ? void 0 : l.getAttribute("data-swup-animation")) || void 0;return u && (t.animation.name = u), "object" == typeof e.cache ? (t.cache.read = (_e$cache$read = e.cache.read) !== null && _e$cache$read !== void 0 ? _e$cache$read : t.cache.read, t.cache.write = (_e$cache$write = e.cache.write) !== null && _e$cache$write !== void 0 ? _e$cache$write : t.cache.write) : void 0 !== e.cache && (t.cache = { read: !!e.cache, write: !!e.cache }), delete e.cache, function (s, a) {try {var l = function (s, a) {try {var l = Promise.resolve(c.hooks.call("visit:start", t, void 0)).then(function () {function s() {if (!t.done) return Promise.resolve(c.hooks.call("visit:transition", t, void 0, function () {try {let n;function e(e) {return n ? e : (t.advance(4), Promise.resolve(c.animatePageOut(t)).then(function () {function e() {return Promise.resolve(c.animatePageIn(t)).then(function () {});}const n = function () {if (t.animation.native && document.startViewTransition) return Promise.resolve(document.startViewTransition(function () {try {const e = c.renderPage;return Promise.resolve(a).then(function (n) {return Promise.resolve(e.call(c, t, n));});} catch (t) {return Promise.reject(t);}}).finished).then(function () {});{const e = c.renderPage;return Promise.resolve(a).then(function (n) {return Promise.resolve(e.call(c, t, n)).then(function () {});});}}();return n && n.then ? n.then(e) : e();}));}const o = function () {if (!t.animation.animate) return Promise.resolve(c.hooks.call("animation:skip", void 0)).then(function () {const e = c.renderPage;return Promise.resolve(a).then(function (o) {return Promise.resolve(e.call(c, t, o)).then(function () {n = 1;});});});}();return Promise.resolve(o && o.then ? o.then(e) : e(o));} catch (r) {return Promise.reject(r);}})).then(function () {if (!t.done) return Promise.resolve(c.hooks.call("visit:end", t, void 0, () => c.classes.clear())).then(function () {t.state = 7, c.navigating = !1, c.onVisitEnd && (c.onVisitEnd(), c.onVisitEnd = void 0);});});}t.state = 3;const a = c.hooks.call("page:load", t, { options: e }, function (t, e) {try {function n(t) {return e.page = t, e.cache = !!o, e.page;}let o;return t.cache.read && (o = c.cache.get(t.to.url)), Promise.resolve(o ? n(o) : Promise.resolve(c.fetchPage(t.to.url, e.options)).then(n));} catch (r) {return Promise.reject(r);}});if (a.then(({ html: e }) => {t.advance(5), t.to.html = e, t.to.document = new DOMParser().parseFromString(e, "text/html");}), !t.history.popstate) {const e = t.to.url + t.to.hash;"replace" === t.history.action || t.to.url === c.currentPageUrl ? i(e) : (c.currentHistoryIndex++, r(e, { index: c.currentHistoryIndex }));}c.currentPageUrl = o(), t.history.popstate && c.classes.add("is-popstate"), t.animation.name && c.classes.add(`to-${n(t.animation.name)}`);const l = function () {if (t.animation.wait) return Promise.resolve(a).then(function () {});}();return l && l.then ? l.then(s) : s();});} catch (t) {return a(t);}return l && l.then ? l.then(void 0, a) : l;}(0, function (e) {e && !(e !== null && e !== void 0 && e.aborted) ? (t.state = 9, console.error(e), c.options.skipPopStateHandling = () => (window.location.assign(t.to.url + t.to.hash), !0), window.history.back()) : t.state = 8;});} catch (t) {return a(!0, t);}return l && l.then ? l.then(a.bind(null, !1), a.bind(null, !0)) : a(!1, l);}(0, function (e, n) {if (delete t.to.document, e) throw n;return n;});}const l = function () {if (c.navigating) return function () {if (!(c.visit.state >= 6)) return Promise.resolve(c.hooks.call("visit:abort", c.visit, void 0)).then(function () {delete c.visit.to.document, c.visit.state = 8;});t.state = 2, c.onVisitEnd = () => c.performNavigation(t, e), a = 1;}();}();return Promise.resolve(l && l.then ? l.then(s) : s(l));} catch (h) {return Promise.reject(h);}};function L(t, e = {}, n = {}) {if ("string" != typeof t) throw new Error("swup.navigate() requires a URL parameter");if (this.shouldIgnoreVisit(t, { el: n.el, event: n.event })) return void window.location.assign(t);const { url: o, hash: r } = a.fromUrl(t),i = this.createVisit({ ...n, to: o, hash: r });this.performNavigation(i, e);}const T = function (t) {try {const e = this;return Promise.resolve(e.hooks.call("animation:out:start", t, void 0, () => {e.classes.add("is-changing", "is-animating", "is-leaving");})).then(function () {return Promise.resolve(e.hooks.call("animation:out:await", t, { skip: !1 }, (t, { skip: n }) => {if (!n) return e.awaitAnimations({ selector: t.animation.selector });})).then(function () {return Promise.resolve(e.hooks.call("animation:out:end", t, void 0)).then(function () {});});});} catch (t) {return Promise.reject(t);}},q = function (t) {var _e$querySelector;const e = t.to.document;if (!e) return !1;const n = ((_e$querySelector = e.querySelector("title")) === null || _e$querySelector === void 0 ? void 0 : _e$querySelector.innerText) || "";document.title = n;const o = m('[data-swup-persist]:not([data-swup-persist=""])'),r = t.containers.map(t => {const n = document.querySelector(t),o = e.querySelector(t);return n && o ? (n.replaceWith(o.cloneNode(!0)), !0) : (n || console.warn(`[swup] Container missing in current document: ${t}`), o || console.warn(`[swup] Container missing in incoming document: ${t}`), !1);}).filter(Boolean);return o.forEach(t => {const e = t.getAttribute("data-swup-persist"),n = d(`[data-swup-persist="${e}"]`);n && n !== t && n.replaceWith(t);}), r.length === t.containers.length;},R = function (t) {const e = { behavior: "auto" },{ target: n, reset: o } = t.scroll,r = n !== null && n !== void 0 ? n : t.to.hash;let i = !1;return r && (i = this.hooks.callSync("scroll:anchor", t, { hash: r, options: e }, (t, { hash: e, options: n }) => {const o = this.getAnchorElement(e);return o && o.scrollIntoView(n), !!o;})), o && !i && (i = this.hooks.callSync("scroll:top", t, { options: e }, (t, { options: e }) => (window.scrollTo({ top: 0, left: 0, ...e }), !0))), i;},N = function (t) {try {const e = this;if (t.done) return Promise.resolve();const n = e.hooks.call("animation:in:await", t, { skip: !1 }, (t, { skip: n }) => {if (!n) return e.awaitAnimations({ selector: t.animation.selector });});return Promise.resolve(f()).then(function () {return Promise.resolve(e.hooks.call("animation:in:start", t, void 0, () => {e.classes.remove("is-animating");})).then(function () {return Promise.resolve(n).then(function () {return Promise.resolve(e.hooks.call("animation:in:end", t, void 0)).then(function () {});});});});} catch (t) {return Promise.reject(t);}},D = function (t, e) {try {const r = this;if (t.done) return Promise.resolve();t.advance(6);const { url: s } = e;return r.isSameResolvedUrl(o(), s) || (i(s), r.currentPageUrl = o(), t.to.url = r.currentPageUrl), Promise.resolve(r.hooks.call("content:replace", t, { page: e }, (t, {}) => {if (r.classes.remove("is-leaving"), t.animation.animate && r.classes.add("is-rendering"), !r.replaceContent(t)) throw new Error("[swup] Container mismatch, aborting");t.animation.animate && (r.classes.add("is-changing", "is-animating", "is-rendering"), t.animation.name && r.classes.add(`to-${n(t.animation.name)}`));})).then(function () {return Promise.resolve(r.hooks.call("content:scroll", t, void 0, () => r.scrollToContent(t))).then(function () {return Promise.resolve(r.hooks.call("page:view", t, { url: r.currentPageUrl, title: document.title })).then(function () {});});});} catch (t) {return Promise.reject(t);}},M = function (t) {var _e2;var e;if (e = t, Boolean((_e2 = e) === null || _e2 === void 0 ? void 0 : _e2.isSwupPlugin)) {if (t.swup = this, !t._checkRequirements || t._checkRequirements()) return t._beforeMount && t._beforeMount(), t.mount(), this.plugins.push(t), this.plugins;} else console.error("Not a swup plugin instance", t);};function O(t) {const e = this.findPlugin(t);if (e) return e.unmount(), e._afterUnmount && e._afterUnmount(), this.plugins = this.plugins.filter(t => t !== e), this.plugins;console.error("No such plugin", e);}function W(t) {return this.plugins.find(e => e === t || e.name === t || e.name === `Swup${String(t)}`);}function B(t) {if ("function" != typeof this.options.resolveUrl) return console.warn("[swup] options.resolveUrl expects a callback function."), t;const e = this.options.resolveUrl(t);return e && "string" == typeof e ? e.startsWith("//") || e.startsWith("http") ? (console.warn("[swup] options.resolveUrl needs to return a relative url"), t) : e : (console.warn("[swup] options.resolveUrl needs to return a url"), t);}function _(t, e) {return this.resolveUrl(t) === this.resolveUrl(e);}const F = { animateHistoryBrowsing: !1, animationSelector: '[class*="transition-"]', animationScope: "html", cache: !0, containers: ["#swup"], ignoreVisit: (t, { el: e } = {}) => !!(e !== null && e !== void 0 && e.closest("[data-no-swup]")), linkSelector: "a[href]", linkToSelf: "scroll", native: !1, plugins: [], resolveUrl: t => t, requestHeaders: { "X-Requested-With": "swup", Accept: "text/html, application/xhtml+xml" }, skipPopStateHandling: t => {var _t$state;return "swup" !== ((_t$state = t.state) === null || _t$state === void 0 ? void 0 : _t$state.source);}, timeout: 0 };class K {constructor(t = {}) {var _ref, _window$history$state;this.version = "4.6.1", this.options = void 0, this.defaults = F, this.plugins = [], this.visit = void 0, this.cache = void 0, this.hooks = void 0, this.classes = void 0, this.currentPageUrl = o(), this.currentHistoryIndex = void 0, this.clickDelegate = void 0, this.navigating = !1, this.onVisitEnd = void 0, this.use = M, this.unuse = O, this.findPlugin = W, this.log = () => {}, this.navigate = L, this.performNavigation = I, this.createVisit = P, this.delegateEvent = s, this.fetchPage = l, this.awaitAnimations = $, this.renderPage = D, this.replaceContent = q, this.animatePageIn = N, this.animatePageOut = T, this.scrollToContent = R, this.getAnchorElement = C, this.getCurrentUrl = o, this.resolveUrl = B, this.isSameResolvedUrl = _, this.options = { ...this.defaults, ...t }, this.handleLinkClick = this.handleLinkClick.bind(this), this.handlePopState = this.handlePopState.bind(this), this.cache = new u(this), this.classes = new w(this), this.hooks = new U(this), this.visit = this.createVisit({ to: "" }), this.currentHistoryIndex = (_ref = (_window$history$state = window.history.state) === null || _window$history$state === void 0 ? void 0 : _window$history$state.index) !== null && _ref !== void 0 ? _ref : 1, this.enable();}enable() {try {var _window$history$state2;const t = this,{ linkSelector: e } = t.options;return t.clickDelegate = t.delegateEvent(e, "click", t.handleLinkClick), window.addEventListener("popstate", t.handlePopState), t.options.animateHistoryBrowsing && (window.history.scrollRestoration = "manual"), t.options.native = t.options.native && !!document.startViewTransition, t.options.plugins.forEach(e => t.use(e)), "swup" !== ((_window$history$state2 = window.history.state) === null || _window$history$state2 === void 0 ? void 0 : _window$history$state2.source) && i(null, { index: t.currentHistoryIndex }), Promise.resolve(f()).then(function () {return Promise.resolve(t.hooks.call("enable", void 0, void 0, () => {const e = document.documentElement;e.classList.add("swup-enabled"), e.classList.toggle("swup-native", t.options.native);})).then(function () {});});} catch (t) {return Promise.reject(t);}}destroy() {try {const t = this;return t.clickDelegate.destroy(), window.removeEventListener("popstate", t.handlePopState), t.cache.clear(), t.options.plugins.forEach(e => t.unuse(e)), Promise.resolve(t.hooks.call("disable", void 0, void 0, () => {const t = document.documentElement;t.classList.remove("swup-enabled"), t.classList.remove("swup-native");})).then(function () {t.hooks.clear();});} catch (t) {return Promise.reject(t);}}shouldIgnoreVisit(t, { el: e, event: n } = {}) {const { origin: o, url: r, hash: i } = a.fromUrl(t);return o !== window.location.origin || !(!e || !this.triggerWillOpenNewWindow(e)) || !!this.options.ignoreVisit(r + i, { el: e, event: n });}handleLinkClick(t) {const e = t.delegateTarget,{ href: n, url: o, hash: r } = a.fromElement(e);if (this.shouldIgnoreVisit(n, { el: e, event: t })) return;if (this.navigating && o === this.visit.to.url) return void t.preventDefault();const s = this.createVisit({ to: o, hash: r, el: e, event: t });t.metaKey || t.ctrlKey || t.shiftKey || t.altKey ? this.hooks.callSync("link:newtab", s, { href: n }) : 0 === t.button && this.hooks.callSync("link:click", s, { el: e, event: t }, () => {var _s$from$url;const e = (_s$from$url = s.from.url) !== null && _s$from$url !== void 0 ? _s$from$url : "";t.preventDefault(), o && o !== e ? this.isSameResolvedUrl(o, e) || this.performNavigation(s) : r ? this.hooks.callSync("link:anchor", s, { hash: r }, () => {i(o + r), this.scrollToContent(s);}) : this.hooks.callSync("link:self", s, void 0, () => {"navigate" === this.options.linkToSelf ? this.performNavigation(s) : (i(o), this.scrollToContent(s));});});}handlePopState(t) {var _ref2, _t$state2, _ref3, _t$state3;const e = (_ref2 = (_t$state2 = t.state) === null || _t$state2 === void 0 ? void 0 : _t$state2.url) !== null && _ref2 !== void 0 ? _ref2 : window.location.href;if (this.options.skipPopStateHandling(t)) return;if (this.isSameResolvedUrl(o(), this.currentPageUrl)) return;const { url: n, hash: r } = a.fromUrl(e),i = this.createVisit({ to: n, hash: r, event: t });i.history.popstate = !0;const s = (_ref3 = (_t$state3 = t.state) === null || _t$state3 === void 0 ? void 0 : _t$state3.index) !== null && _ref3 !== void 0 ? _ref3 : 0;s && s !== this.currentHistoryIndex && (i.history.direction = s - this.currentHistoryIndex > 0 ? "forwards" : "backwards", this.currentHistoryIndex = s), i.animation.animate = !1, i.scroll.reset = !1, i.scroll.target = !1, this.options.animateHistoryBrowsing && (i.animation.animate = !0, i.scroll.reset = !0), this.hooks.callSync("history:popstate", i, { event: t }, () => {this.performNavigation(i);});}triggerWillOpenNewWindow(t) {return !!t.matches('[download], [target="_blank"]');}}export { a as Location, n as classify, r as createHistoryRecord, K as default, s as delegateEvent, g as forceReflow, o as getCurrentUrl, p as isPromise, c as matchPath, f as nextTick, d as query, m as queryAll, v as runAsPromise, i as updateHistoryRecord };