import o from "../../plugin@4.0.0/dist/index.module.js?module";import { queryAll as t } from "../../../swup@4.6.1/dist/Swup.module.js?module";import s from "../../../scrl@2.0.0/dist/index.module.js?module";class e extends o {constructor(o = {}) {super(), this.name = "SwupScrollPlugin", this.requires = { swup: ">=4.2.0" }, this.scrl = void 0, this.defaults = { doScrollingRightAway: !1, animateScroll: { betweenPages: !0, samePageWithHash: !0, samePage: !0 }, scrollFriction: .3, scrollAcceleration: .04, getAnchorElement: void 0, offset: 0, scrollContainers: "[data-swup-scroll-container]", shouldResetScrollPosition: () => !0, markScrollTarget: !1 }, this.options = void 0, this.cachedScrollPositions = {}, this.previousScrollRestoration = void 0, this.currentCacheKey = void 0, this.getAnchorElement = (o = "") => "function" == typeof this.options.getAnchorElement ? this.options.getAnchorElement(o) : this.swup.getAnchorElement(o), this.getOffset = o => o ? "function" == typeof this.options.offset ? parseInt(String(this.options.offset(o)), 10) : parseInt(String(this.options.offset), 10) : 0, this.onBeforeLinkToSelf = o => {o.scroll.animate = this.shouldAnimate("samePage");}, this.handleScrollToTop = o => {var _this$swup$scrollTo, _this$swup;return (_this$swup$scrollTo = (_this$swup = this.swup).scrollTo) !== null && _this$swup$scrollTo !== void 0 && _this$swup$scrollTo.call(_this$swup, 0, o.scroll.animate), !0;}, this.onBeforeLinkToAnchor = o => {o.scroll.animate = this.shouldAnimate("samePageWithHash");}, this.handleScrollToAnchor = (o, { hash: t }) => this.maybeScrollToAnchor(t, o.scroll.animate), this.onBeforeVisitStart = o => {o.scroll.scrolledToContent = !1, o.scroll.animate = this.shouldAnimate("betweenPages");}, this.onVisitStart = o => {var _o$scroll$target;this.cacheScrollPositions(o.from.url), this.maybeResetScrollPositions(o), o.scroll.animate && this.options.doScrollingRightAway && !((_o$scroll$target = o.scroll.target) !== null && _o$scroll$target !== void 0 ? _o$scroll$target : o.to.hash) && this.doScrollingBetweenPages(o);}, this.handleScrollToContent = o => {o.scroll.scrolledToContent || this.doScrollingBetweenPages(o), this.restoreScrollContainers(o.to.url);}, this.doScrollingBetweenPages = o => {var _o$scroll$target2, _s$window;if (o.history.popstate && !o.animation.animate) return;const t = (_o$scroll$target2 = o.scroll.target) !== null && _o$scroll$target2 !== void 0 ? _o$scroll$target2 : o.to.hash;if (t && this.maybeScrollToAnchor(t, o.scroll.animate)) return;if (!o.scroll.reset) return;const s = this.getCachedScrollPositions(o.to.url),e = (s === null || s === void 0 ? void 0 : (_s$window = s.window) === null || _s$window === void 0 ? void 0 : _s$window.top) || 0;requestAnimationFrame(() => {var _this$swup$scrollTo2, _this$swup2;return (_this$swup$scrollTo2 = (_this$swup2 = this.swup).scrollTo) === null || _this$swup$scrollTo2 === void 0 ? void 0 : _this$swup$scrollTo2.call(_this$swup2, e, o.scroll.animate);}), o.scroll.scrolledToContent = !0;}, this.maybeResetScrollPositions = o => {const { popstate: t } = o.history,{ url: s } = o.to,{ el: e } = o.trigger;t || e && !this.options.shouldResetScrollPosition(e) || this.resetScrollPositions(s);}, this.options = { ...this.defaults, ...o };}mount() {const o = this.swup;o.hooks.create("scroll:start"), o.hooks.create("scroll:end");const t = this.swup.createVisit({ to: this.swup.currentPageUrl });this.scrl = new s({ onStart: () => o.hooks.callSync("scroll:start", t, void 0), onEnd: () => o.hooks.callSync("scroll:end", t, void 0), onCancel: () => o.hooks.callSync("scroll:end", t, void 0), friction: this.options.scrollFriction, acceleration: this.options.scrollAcceleration }), o.scrollTo = (s, e = !0) => {e ? this.scrl.scrollTo(s) : (o.hooks.callSync("scroll:start", t, void 0), window.scrollTo(0, s), o.hooks.callSync("scroll:end", t, void 0));}, this.previousScrollRestoration = window.history.scrollRestoration, o.options.animateHistoryBrowsing && (window.history.scrollRestoration = "manual"), this.updateScrollTarget = this.updateScrollTarget.bind(this), this.options.markScrollTarget && (window.addEventListener("popstate", this.updateScrollTarget), window.addEventListener("hashchange", this.updateScrollTarget), this.on("page:view", this.updateScrollTarget), this.on("link:anchor", this.updateScrollTarget), this.on("link:self", this.updateScrollTarget), this.updateScrollTarget()), this.before("visit:start", this.onBeforeVisitStart, { priority: -1 }), this.on("visit:start", this.onVisitStart, { priority: 1 }), this.replace("content:scroll", this.handleScrollToContent), this.before("link:self", this.onBeforeLinkToSelf, { priority: -1 }), this.replace("scroll:top", this.handleScrollToTop), this.before("link:anchor", this.onBeforeLinkToAnchor, { priority: -1 }), this.replace("scroll:anchor", this.handleScrollToAnchor);}unmount() {super.unmount(), this.previousScrollRestoration && (window.history.scrollRestoration = this.previousScrollRestoration), window.removeEventListener("popstate", this.updateScrollTarget), window.removeEventListener("hashchange", this.updateScrollTarget), this.cachedScrollPositions = {}, delete this.swup.scrollTo, delete this.scrl;}shouldAnimate(o) {return "boolean" == typeof this.options.animateScroll ? this.options.animateScroll : this.options.animateScroll[o];}maybeScrollToAnchor(o, t = !1) {var _this$swup$scrollTo3, _this$swup3;if (!o) return !1;const s = this.getAnchorElement(o);if (!s) return console.warn(`Anchor target ${o} not found`), !1;if (!(s instanceof Element)) return console.warn(`Anchor target ${o} is not a DOM node`), !1;const { top: e } = s.getBoundingClientRect(),l = e + window.scrollY - this.getOffset(s);return (_this$swup$scrollTo3 = (_this$swup3 = this.swup).scrollTo) !== null && _this$swup$scrollTo3 !== void 0 && _this$swup$scrollTo3.call(_this$swup3, l, t), !0;}cacheScrollPositions(o) {const s = this.swup.resolveUrl(o),e = t(this.options.scrollContainers).map(o => ({ top: o.scrollTop, left: o.scrollLeft })),l = { window: { top: window.scrollY, left: window.scrollX }, containers: e };this.cachedScrollPositions[s] = l;}resetScrollPositions(o) {const t = this.swup.resolveUrl(o);delete this.cachedScrollPositions[t];}getCachedScrollPositions(o) {const t = this.swup.resolveUrl(o);return this.cachedScrollPositions[t];}restoreScrollContainers(o) {const s = this.getCachedScrollPositions(o);s && 0 !== s.containers.length && t(this.options.scrollContainers).forEach((o, t) => {const e = s.containers[t];null != e && (o.scrollTop = e.top, o.scrollLeft = e.left);});}updateScrollTarget() {var _s;const { hash: o } = window.location,t = document.querySelector("[data-swup-scroll-target]");let s = this.getAnchorElement(o);s instanceof HTMLBodyElement && (s = null), t !== s && (t !== null && t !== void 0 && t.removeAttribute("data-swup-scroll-target"), (_s = s) === null || _s === void 0 ? void 0 : _s.setAttribute("data-swup-scroll-target", ""));}}export { e as default };