import e from "../../plugin@4.0.0/dist/index.module.js?module";import { Location as t, getCurrentUrl as r } from "../../../swup@4.6.1/dist/Swup.module.js?module";function o() {return window.matchMedia("(hover: hover)").matches;}function s(e) {return !!e && (e instanceof HTMLAnchorElement || e instanceof SVGAElement);}const i = window.requestIdleCallback || (e => setTimeout(e, 1));class n extends e {constructor(e = {}) {super();const r = this;this.name = "SwupPreloadPlugin", this.requires = { swup: ">=4.5" }, this.defaults = { throttle: 5, preloadInitialPage: !0, preloadHoveredLinks: !0, preloadVisibleLinks: { enabled: !1, threshold: .2, delay: 500, containers: ["body"], ignore: () => !1 } }, this.options = void 0, this.queue = void 0, this.preloadObserver = void 0, this.preloadPromises = new Map(), this.mouseEnterDelegate = void 0, this.touchStartDelegate = void 0, this.focusDelegate = void 0, this.onPageLoad = (e, t, r) => {const { url: o } = e.to;return o && this.preloadPromises.has(o) ? this.preloadPromises.get(o) : r(e, t);}, this.onMouseEnter = function (e) {try {if (e.target !== e.delegateTarget) return Promise.resolve();if (!o()) return Promise.resolve();const i = e.delegateTarget;if (!s(i)) return Promise.resolve();const { url: n, hash: a } = t.fromElement(i),l = r.swup.createVisit({ to: n, hash: a, el: i, event: e });return r.swup.hooks.callSync("link:hover", l, { el: i, event: e }), r.preload(i, { priority: !0 }), Promise.resolve();} catch (e) {return Promise.reject(e);}}, this.onTouchStart = e => {if (o()) return;const t = e.delegateTarget;s(t) && this.preload(t, { priority: !0 });}, this.onFocus = e => {const t = e.delegateTarget;s(t) && this.preload(t, { priority: !0 });};const { preloadVisibleLinks: i, ...n } = e;this.options = { ...this.defaults, ...n }, "object" == typeof i ? this.options.preloadVisibleLinks = { ...this.options.preloadVisibleLinks, enabled: !0, ...i } : this.options.preloadVisibleLinks.enabled = Boolean(i), this.preload = this.preload.bind(this), this.queue = function (e = 1) {const t = [],r = [];let o = 0,s = 0;function i() {s < e && o > 0 && ((r.shift() || t.shift() || (() => {}))(), o--, s++);}return { add: function (e, s = !1) {if (e.__queued) {if (!s) return;{const r = t.indexOf(e);if (r >= 0) {const e = t.splice(r, 1);o -= e.length;}}}e.__queued = !0, (s ? r : t).push(e), o++, o <= 1 && i();}, next: function () {s--, i();} };}(this.options.throttle);}mount() {const e = this.swup;e.options.cache ? (e.hooks.create("page:preload"), e.hooks.create("link:hover"), e.preload = this.preload, e.preloadLinks = this.preloadLinks, this.replace("page:load", this.onPageLoad), this.preloadLinks(), this.on("page:view", () => this.preloadLinks()), this.options.preloadVisibleLinks.enabled && (this.preloadVisibleLinks(), this.on("page:view", () => this.preloadVisibleLinks())), this.options.preloadHoveredLinks && this.preloadLinksOnAttention(), this.options.preloadInitialPage && this.preload(r())) : console.warn("SwupPreloadPlugin: swup cache needs to be enabled for preloading");}unmount() {var _this$mouseEnterDeleg, _this$touchStartDeleg, _this$focusDelegate;this.swup.preload = void 0, this.swup.preloadLinks = void 0, this.preloadPromises.clear(), (_this$mouseEnterDeleg = this.mouseEnterDelegate) !== null && _this$mouseEnterDeleg !== void 0 && _this$mouseEnterDeleg.destroy(), (_this$touchStartDeleg = this.touchStartDelegate) !== null && _this$touchStartDeleg !== void 0 && _this$touchStartDeleg.destroy(), (_this$focusDelegate = this.focusDelegate) !== null && _this$focusDelegate !== void 0 && _this$focusDelegate.destroy(), this.stopPreloadingVisibleLinks();}preload(e, r = {}) {try {var _r$priority;const o = this;let i, n;const a = (_r$priority = r.priority) !== null && _r$priority !== void 0 ? _r$priority : !1;if (Array.isArray(e)) return Promise.all(e.map(e => o.preload(e)));if (s(e)) n = e, ({ href: i } = t.fromElement(e));else {if ("string" != typeof e) return Promise.resolve();i = e;}if (!i) return Promise.resolve();if (o.preloadPromises.has(i)) return Promise.resolve(o.preloadPromises.get(i));if (!o.shouldPreload(i, { el: n })) return Promise.resolve();const l = new Promise(e => {o.queue.add(() => {o.performPreload(i).catch(() => {}).then(t => e(t)).finally(() => {o.queue.next(), o.preloadPromises.delete(i);});}, a);});return o.preloadPromises.set(i, l), Promise.resolve(l);} catch (e) {return Promise.reject(e);}}preloadLinks() {i(() => {Array.from(document.querySelectorAll("a[data-swup-preload], [data-swup-preload-all] a")).forEach(e => this.preload(e));});}preloadLinksOnAttention() {const { swup: e } = this,{ linkSelector: t } = e.options,r = { passive: !0, capture: !0 };this.mouseEnterDelegate = e.delegateEvent(t, "mouseenter", this.onMouseEnter, r), this.touchStartDelegate = e.delegateEvent(t, "touchstart", this.onTouchStart, r), this.focusDelegate = e.delegateEvent(t, "focus", this.onFocus, r);}preloadVisibleLinks() {if (this.preloadObserver) return void this.preloadObserver.update();const { threshold: e, delay: r, containers: o } = this.options.preloadVisibleLinks;this.preloadObserver = function ({ threshold: e, delay: r, containers: o, callback: s, filter: n }) {const a = new Map(),l = new IntersectionObserver(e => {e.forEach(e => {e.isIntersecting ? h(e.target) : d(e.target);});}, { threshold: e }),h = e => {var _a$get;const { href: o } = t.fromElement(e),i = (_a$get = a.get(o)) !== null && _a$get !== void 0 ? _a$get : new Set();a.set(o, i), i.add(e), setTimeout(() => {const t = a.get(o);(t === null || t === void 0 ? void 0 : t.size) && (s(e), l.unobserve(e), t.delete(e));}, r);},d = e => {var _a$get2;const { href: r } = t.fromElement(e);(_a$get2 = a.get(r)) === null || _a$get2 === void 0 ? void 0 : _a$get2.delete(e);},p = () => {i(() => {const e = o.map(e => `${e} a[*|href]`).join(", ");Array.from(document.querySelectorAll(e)).filter(e => n(e)).forEach(e => l.observe(e));});};return { start: () => p(), stop: () => l.disconnect(), update: () => (a.clear(), p()) };}({ threshold: e, delay: r, containers: o, callback: e => this.preload(e), filter: e => {if (this.options.preloadVisibleLinks.ignore(e)) return !1;if (!e.matches(this.swup.options.linkSelector)) return !1;const { href: r } = t.fromElement(e);return this.shouldPreload(r, { el: e });} }), this.preloadObserver.start();}stopPreloadingVisibleLinks() {this.preloadObserver && this.preloadObserver.stop();}shouldPreload(e, { el: o } = {}) {const { url: s, href: i } = t.fromUrl(e);return !(!function () {if (navigator.connection) {var _navigator$connection;if (navigator.connection.saveData) return !1;if ((_navigator$connection = navigator.connection.effectiveType) !== null && _navigator$connection !== void 0 && _navigator$connection.endsWith("2g")) return !1;}return !0;}() || this.swup.cache.has(s) || this.preloadPromises.has(s) || this.swup.shouldIgnoreVisit(i, { el: o }) || o && this.swup.resolveUrl(s) === this.swup.resolveUrl(r()));}performPreload(e) {try {const r = this,{ url: o } = t.fromUrl(e),s = r.swup.createVisit({ to: o });return Promise.resolve(r.swup.hooks.call("page:preload", s, { url: o }, function (t, o) {try {return Promise.resolve(r.swup.fetchPage(e, { visit: t })).then(function (e) {return o.page = e, o.page;});} catch (e) {return Promise.reject(e);}}));} catch (e) {return Promise.reject(e);}}}export { n as default };
